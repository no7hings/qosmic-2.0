>主要用于优化Maya的性能，分为两个部分，绑定优化和场景优化。
>优化的目的为提高动画制作时候的流畅度，主要表现为：
>	1. 减少视窗的显示压力（表现为视窗帧率提高）；
>	2. 减少文件和缓存的加载时间；
>	3. 减少因为工具繁琐操作和工具执行过程中Maya主进程阻塞（Maya操作界面卡死）导致的等待时间。
## 关键词（Keyword）
- 多进程任务池（Prc-Task Pool）
	在不阻塞Maya主进程的情况下，利用子进程在后台运行多个Maya（也可以是其他软件）处理耗时长的任务。
	执行的逻辑为同时执行的最大任务数量为N，如任务超过N，N之后的任务便会进入等待。当之前的N个任务中的任意一个任务执行结束，N之后的任务便会加入执行队列。
- GPU缓存（GPU Cache）
	GPU 缓存文件从 Alembic 开源文件格式开发而来，通过优化这些文件可提高 Maya 中的播放性能。根据对 GPU 缓存文件进行求值的方式来实现性能提升。GPU 缓存节点直接将缓存的数据路由到系统显卡，以处理、忽略 Maya 依存关系图求值。此数据流可缓解在打开和播放具有庞大数据集的大型场景时出现的性能问题。
- 场景组装（Scene Assembly）
	使用此功能可以创建、编辑和查看大型或复杂场景，不会出现通常导致工作流程速度下降的典型内存开销。使用场景集合构建场景可以提高视口交互性、减少场景加载时间，并防止处理大型数据集时所出现的某些常见问题。
## 工具预览（Too Preview）
>设计逻辑：
>	使用多进程和多线程提高运行速度，减少主进程阻塞；
>	集成常用命令和工具，优化操作链路，减少导出找工具花费的时间。
>绑定工具主要的工具为生成简模代理和动态GPU：
>	资源视图可与Maya的视窗交互（在maya中选中任意绑定的任意部件，资源视图中的对应绑定资源变回高亮，反之亦然）；
>	快速筛选满足条件的绑定资源；
>	集成了maya的单独显示的部分功能，可快速单独显示/加选/减选某个绑定资源；
>	集成了maya的引用编辑器的部分工具，可快速移除/复制/加载/卸载绑定资源。
>	动画传递/复制/粘贴工具可以提高动作制作的效率（更多功能后续会加入）
>场景工具（开发中）

![[resource-manager.png]]
![[resource-manager-rig-extend.png]]
### 多进程任务池功能示意
- 运行中（Running）&等待（Waiting）
	当6个任务需要执行进度条会被平均分为6段，会先同时执行5个（颜色为蓝色），第6任务会进入等待（颜色为橙色），如前面5个任务有任意一个执行结束（结束状态有两种，成功和失败，成功为绿色，失败为红色），第6个任务便会结束等待开始执行

![[process-task-button-waiting.png]]
- 完成（Completed）
	任务结束的状态为绿色

![[process-task-button-completed.png]]
## 绑定优化
>目前绑定的资源存在以下几个问题：
>	模型面数较大，对视窗的显示压力较大；
>	资产阶段没有简模绑定；
>	*资产阶段没有做绑定优化（如节点优化连接，减少不支持GPU加速的节点使用，减少冗余节点和无用的中间节点）*。
>优化思路：
>	1. 根据骨骼自动生成简模代理，减少因模型面数过多对Maya视窗造成的显示压力（比较有限），并节省制作简模花费的时间成本。可在分镜（Layout）阶段或者不需要调整衣服动画的阶段使用。
>	2. 生成动态GPU，减少因模型面数过多对Maya视窗造成的显示压力（效果比较明显）。如某个或几个绑定不需要继续做动画调整的时候可考虑以此种的形式进行优化。

### 简模代理（Skin Proxy）
>目前已有简模导入工具，但是有以下几个缺点：
>	1. 需要人工制作简模；
>	2. 加载的时候绑定必须在原点，必须为默认Pose；
>	3. 驱动的方式为蒙皮，比较消耗资源。
>优化后：
>	1. 会根据ADV身体骨骼自动生成简模，减少人工成本；
>	2. 任意状态下都可加载（不受限于位置及Pose）；
>	3. 驱动方式为约束，省资源；
>	4. 所有的节点被封装在一个容器中，方便干净的移除；
>	5. 会根据绑定文件关键信息进行缓存，不会重复生成，减少存储资源占用；
>	6. 略微减少视窗的显示压力。

### 动态GPU（Dynamic GPU）
>目前Maya有带动画的GPU，但是有以下几个缺点：
>	1. 输出为单个文件，加载压力较大；
>	2. 无法循环和随意偏移
>优化后：
>	1. 大大的减少视窗的显示压力；
>	2. 将每一帧输出成单独的文件，降低加载的压力；
>	3. 支持循环和随意偏移；
>	4. 如临时卸载（Unload）绑定也可显著提高加载文件的时间。
>缺点：
>	1. 比较占用存储资源，但是这些都是临时缓存，可存在制作人员本地，并定时自动清理即可。

## 场景优化
>目前场景资源存在以下几个问题：
>	1. 模型面数较大，并以模型的显示进行像是（部分生成了GPU），对视窗的显示压力巨大（卡顿的主要原因）；
>	2. 部分生成的GPU是个整体，不利于分镜（Layout）和动画环境进行交互；
>	3. 制作方式比较传统，不利于资源的重复利用。
>优化思路：
>	1. 全部使用GPU进行显示；
>	2. 每个元素都生成多个LOD（用于不同的显示需求，如里镜头较远的可以用较低面数的LOD）；
>	3. 生成场景组装，方便在GPU和Mesh之间进行切换（包含不同LOD）；
>	4. 利用相机遮罩动态隐藏镜头相机中不可见的元素。

### 元素组装（Unit Assembly）
>优化逻辑：
>	1. 根据Mesh的拓扑自动生成组装元素，相同拓扑的Mesh只会生成一次，相同的节点会以实例的形式进行引用，减少节点数量；
>	2. 会自动搜索丢失的贴图和缓存（GPU）；
>	3. 只会转化Mesh和GPU，会保留其他类型的节点， 如灯光等；
>	4. Mesh会保留材质和贴图信息；
>	5. 会保留原有的层级结构；
>	6. 整体的GPU会进行合理拆分；
>	7. 生成场景组装。
>优化后：
>	1. 显著减少场景的加载时间；
>	2. 可在GPU和Mesh直接进行随意切换（包含不同LOD），根据不用的需求进行显示；
>	3. 会根据绑定文件关键信息进行缓存，不会重复生成，减少存储资源占用；
>	4. 略微减少视窗的显示压力；
>	5. 显著的提高文件的加载速度

### 相机遮罩（Camera Mask）
>优化逻辑：
>	1. 根据场景元素与相机的视角自动隐藏不在相机中的元素，减少其他视图中同时显示的场景元素数量；
>优化后：
>	1. 如镜头变化不大，切为中近景可显著减少视窗的显示压力

