> 讨论主要分为三个部分，解算任务流程， 解算制作流程，MAYA和文件夹层级结构
## 解算任务示意图
> 资产环节增加解算绑定任务，制作解算绑定用于镜头解算
> 镜头环节增加解算任务，开发对应的工具辅助解算
> 有两套方案
## 方案A
>比较传统的方案，直接在绑定的基础上制作解算绑定，解算的时候直接引用动画文件然后替换绑定为解算绑定（也可另存和导入，但是存在动画更新的问题）。
>优点：可以用绑定的控制器，制作简单，所见即所得，可纯手动制作，对工具的依赖较少；
>缺点：绑定资产较重，解算任务与动画任务的对接方式为双重引用，比较卡，也容易出BUG（保留了绑定和动画的所有节点和历史记录）。
![[cfx_task_flow_a.png]]
### 方案B
>动画公司的主流方案，解算绑定利用bridge模型和缓存/绑定的模型（制作解算绑定时）进行融合，需要有配套工具辅助
>优点：解算的时候只需要用到缓存，文件较轻（隔离了绑定和动画的所有节点和历史记录，只有缓存相关的节点），更新方便，制作相对流畅，BUG少（节点少了）；
>缺点：无法单独使用，必须和缓存进行融合。没有控制器，对解算绑定的制作水平要求较高，对自动化工具的依赖程度比较高。
>其他：也可以增加与绑定进行桥接的方式，但是动画需要输出每个角色的动画数据。
![[cfx_task_flow_b.png]]
## 解算绑定制作示意图
>方案B和A最大的不同就是多了一个桥接模型来代替绑定模型（这个模型在镜头解算的时候被缓存融合驱动，来继承动画数据）。
>两套方案的核心就是解算模型（方案B的桥接模型也需要）要和源模型的拓扑保持一致。
### 方案A
![[cfx_dcc_flow_a.png]]
### 方案B
![[cfx_dcc_flow_b.png]]
## 推荐MAYA层级结构/命名
>会有工具自动创建主要的组。
>推荐全小写命名，避免因为大小写导致的命名错误，每个分组的子组推荐命名方式为"\{name\}\_grp"，有遗漏的可以补充。
- root（根组）
	- cfx_grp
		- *cfx_bridge_grp*（在方案B中存放桥接模型）
		- cfx_cloth_proxy_grp（存放布料简模代理，一些比较复杂的布料会制作简模进行解算）
		- cfx_cloth_grp（需要输出缓存的布料模型，确保模型的名字与绑定的名字是一致的，方便后面做拓扑对比，里面的物体过多可以自由分组）
			- \{name\}\_grp
		- ~~cfx_hair_grp~~（后续如果有毛发解算放在这个组， 下面还有更细化在组）
		- cfx_collider_grp（碰撞模型，不会输出缓存）
			-  \{name\}\_grp
		- cfx_dynamic_grp（解算器，力场等）
			- \{name\}\_grp
		- cfx_auxiliary_grp（辅助物体，包裹体等， 不会输出缓存）
			- \{name\}\_grp
## 推荐项目文件夹结构
> 由于后续要用到农场解算，制作文件必须存在服务器上，得有一个区域用于存放解算制作文件
### 解算绑定存放路径
- ...
	- \{asset\}
		- cfx_rig
			- scene
				- \{asset\}.cfx_rig.ma

### 制作文件存放路径
- ...
	- \{user\}
		- \{project\}.\{shot\}
			- scene
				- \{project\}.\{shot\}.\{version\}.ma
			- cache
				- \{project\}.\{shot\}.\{version\}
					- abc
						- \{namespace\}.cloth.abc
					- json
						- \{namespace\}.cloth.json